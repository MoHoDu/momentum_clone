# TCP/IP

---------------------------------------------------
"인터넷이 뭐지?"
전 세계에 걸쳐서 파일 전송 등 데이터 통신 서비스를 받을 수 있는
컴퓨터 네트워크 시스템!
SK, LG 등 : 네트워크 인프라
- 기업이 미리 구축해 놓은 네트워크를 우리가 돈을 주고 사용하고 있음
- 이런 거대한 인프라를 통해서 우리는...
    '데이터'를 '디지털 신호'로 전달하고,
    다시 '데이터'로 변환해서 받는 네트워크 통신을 하게 된다.

--> 이 통신 과정에서의 공통적인 메뉴얼을 '프로토콜'이라고 한다.
    그리고, 우리가 얘기할 TCP와 IP는 모두 프로토콜에 해당된다.

---------------------------------------------------
"OSI와 TCP/IP 계층과 계층 별 프로토콜"
OSI 7 Layer *
 : ISO(국제표준기구)에서 만든 네트워크를 7계층으로
   만든 모델
TCP/IP @
 : OSI 7 Layer를 4개로 단순화 하여서 구현한 계층

--> 각 계층 별 프로토콜
@ Application Layer
 : 특정 서비스를 제공하기 위해서 매플리케이션끼리 정보를 주고 받는 계층
    * Application Layer
    * Presentation Layer
    * Session Layer
 - 주요 프로토콜 -> FTP, HTTP, SMTP, 'DNS', TELNET, SSH
@ Transport Layer
 : 송신된 데이터를 수신측 애플리케이션에 확실히 전달하게 해주는 계층
    * Transport Layer
 - 주요 프로토콜 -> 'TCP', 'UDP', RTP, RTCP
@ Internet Layer
 : 수신측까지 데이터를 전달하기 위해 사용하는 계층
    * Network Layer
 - 주요 프로토콜 -> 'IP', ARP, ICMP, RARP, OSPF
@ Network Access Layer
 : 네트어크에 직접 연결된 기기간 전송을 할 수 있게 해주는 계층
    * Data-Link Layer
    * Physical Layer
 - 주요 프로토콜 -> 'Ethernet', PPP, Token_Ring

--> 데이터를 전송 시에는 위에서 아래로 받을 때에는 역순으로

---------------------------------------------------
"우리가 'www.google.com'에 접속하면?"
 - 구글 웹서버 :80포트로 HTTP Request 메세지를 전송해야 함
전송을 위해서 각 계층에서 필요한 정보를 패킷에 담아야 함
(각 계층에서 HTTP, TCP, IP, Ethernet을 쓴다고 가정)
1. Application Layer에서 HTTP 프로토콜을 통해 HTTP Request
    메세지 전송
2. Transport Layer에서 TCP를 사용.
 - TCP 헤더에 SP(시작 포트번호)에는 본인 소캣 포트번호를, DP(도착
 포트 번호)에는 구글 웹서버 포트인 80을 넣는다.
3. Internet Layer에서 IP를 사용.
 - IP 패킷 헤더에 SA(시작 IP주소)에 본인 IP주소를 기입하고, DA에는
 구글 서버의 IP를 기입해야 하는데 도메인밖에 알지 못한다.
--> 다시 Application Layer의 'DNS' 프로토콜을 사용하여 도메인
    에 대한 IP주소를 요청한다. 
    1. 브라우저에서 OS에 도메인에 대한 IP주소를 요청
    2. OS가 DNS서버로 도메인을 전달
     - DNS서버는 컴퓨터에 등록되어 있다.
    3. DNS서버가 도메인 서버에 도메인이 담긴 쿼리를 전달
    4. 도메인 서버에서 IP주소를 전달
 - 해당 IP주소를 DA에 넣는다. 
4. Network Layer에서 Ethernet을 사용.
 - 여기서는 goggle 웹서버의 Mac주소는 필요 없고, 본인의 공유기(
   게이트웨이)의 Mac주소만 헤더에 넣는다. 
 - 본인이 가지고 있는 게이트웨이 정보에서 게이트웨이 IP와 ARP프로토콜
   을 통해서 게이트웨이의 Mac주소를 가져온다. 

일단, 패킷에 모든 계층의 정보가 담김
하지만, 바로 이를 보내는 것이 아니다. '연결지향형'인 TCP에 의해 전송
전에 송신, 수신 측이 미리 연결되는 작업이 필요하다.
 - 이를 3-way Handshaking이라고 일컫는다. 
 - TCP헤더에 표시한 플래그(컨트롤 비트) 중에서 SYN과 ACK를 사용
 - 총 3번 신호를 전달한다. 
 - 흐름제어에서도 얘기하겠지만, 이는 처리 가능한 정도의 초기 혼잡 윈
   도우 크기를 결정하는 과정이기도 하다.
1. 클라이언트에서 SYN 패킷을 통해 자신의 버퍼 크기를 알려준다. 
2. 서버 역시 SYN과 ACK 패킷을 통해서 자신의 버퍼 크기와 확인햇음을
   알려준다. 
3. 클라이언트에서 SYN을 자신이 보내고 난 뒤, 답을 받은 시간을 측정
   해서 현재 네트워킹 상황을 유추한다.
4. 이후, 상호간의 버퍼와 네트워킹 상황을 고려해서 윈도우 크기를 정한
   다. 그리고 상호간의 연결이 성립된다. 

이후 정말로 이 패킷을 전달하기 위해 개인 컴퓨터의 private IP를
NAT(Network Address Translation)을 통해 public IP로 바꿈

전달이 시작되면, 컴퓨터에서 게이트웨이 그리고, 여러 라우터를 거쳐서
데이터가 전달된다. 이 과정을 '라우팅'이라고 한다.
그 뒤에 구글 서버가 연결된 마지막 라우터에 도착하는데 여기서 라우터는
ARP프로토콜을 사용해 연결된 모든 서버에 패킷 헤더에 있던 구글서버의 
IP를 브로드 캐스팅(모두에게 동시 전달)하여 구글 서버를 찾는다. 

여기서부터는 데이터를 수신하는 과정이므로 계층 역순으로 절차가 진행
된다. 
1. 구글 서버를 찾기 위해서 패킷 IP헤더(Internet Layer) 속 구글
   서버 IP로 이전에서처럼 Mac주소(Network Layer)를 가져온다.
2. 올바른 구글 서버로 도착한 뒤, Transport Layer의 TCP에서 
   헤더 속 DA에 적힌 80번 포트를 어플리케이션에 전달한다. 
3. Application Layer에서 드디어 HTTP Request 데이터를 받고,
   적절한 응답을 돌려주기 위해 "/"에 매핑된 GET요청을 처리하여
   알맞은 HTML을 전달한다. 

모든 데이터가 오가고 나서는 연결 종료가 이루어져야 한다. 
이 과정에서 역시 신호를 서로 전달하는데 이를 "4-way Handshaking"
이라고 한다. 
1. 클라이언트 : FIN(서버 종료해)
2. 서버 : ACK(좋아 나 종료 할게)를 보내고 통신 서버를 종료
3. 종료한 뒤에 서버 : FIN(나 통신 끝냈어)
4. 클라이언트 : 바로 응답을 해서 연결된 소캣을 닫지 않고, 누락되었을
   수도 있는 데이터들을 기다린다. 이를 "TIME_WAIT"라고 한다.
5. 이후, 일정 시간 기다림을 끝내고 ACK(확인했고 소캣 닫을게)를 
   보내고 소캣을 닫는다. 

---------------------------------------------------
사실 이 과정 속에서 TCP는 엄청나게 큰 데이터를 잘게 쪼개서 여러 패킷
으로 나누어 전달한다. 
그리고 이 패킷들은 복잡한 네트워크망을 통해서 전달되는데...
'연결지향형'이자 '신뢰할 수 있는' 프로토콜인 TCP가 혹여나 복잡한 네
트워크 속에서 일어날 수 있는 패킷 데이터의 손실과 순서의 뒤섞임을 방지
하는 역할도 한다.
 - 이를 '흐름제어', '오류제어' 그리고, '혼잡제어'라고 한다.