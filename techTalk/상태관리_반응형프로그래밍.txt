# 상태관리?
> 상태란?
변화하는 데이터
UI에 동적으로 표현되는 데이터
    사용자의 액션에 따라서 변경 가능한 컴포넌트의 부분을 
    자바스크립트 객체

>상태 관리란?
여러 컴퍼넌트 간에 데이터 전달과 이벤트 통신을 한 곳에서 관리
계속 변화하는 데이터를 알맞게 관리하기 위한 단계

>왜 필요할까?
잦은 페이지 이동이 있는 사이트 사용
    --> 매번 페이지가 다시 그려짐
하지만 지금은 이런 웹 페이지를 사용하길 원하지 않음
    --> 변화된 부분만 변하길 원함
    ex) 좋아요 누른다고 페이지가 새로고침 되지는 않죠
    ex) 다른 사람이 누르는 것도 마찬가지고요
상태가 많아지고 서로 복잡하게 얽혀있다면
- 어떻게 상호간 의존하고 페이지 내부에서 상태들이 흘러가고
- 그에 따라 UI가 어떻게 변하는지 알아차리기가 어려움
- 비동기적이라면 더 끔찍
이를 제대로 알고 있어야 할 필요가 있어서 관리가 중요

작은 단위로 쪼개진 컴포넌트들이 화면을 구성
- 네브바, 슬라이더, 타이틀, 검색 등등
각자 독립적이 아니라 서로 정보를 공유
    ex) 검색을 하면, 검색된 게임들이 보여짐 
상태가 많은 복잡한 규모가 큰 회사에서 더 필요
- 앱의 규모가 커지면 데이터가 많아지고 이동이 빈번해지고
- 중간에 거쳐야할 컴포넌트가 많아짐
- 컴포넌트간 데이터 흐름을 파악하기도 힘들어짐
--> 상태가 필요하고 관리가 필요한 것

>상태 관리와 관련된 다양한 패턴
>패턴
상태관리를 어떻게 할지 미리 타 개발자들이 구성해놓은 솔루션

# 반응형 프로그래밍?
상태 = 변하는 데이터
만약 변화는 하는데 사용하는 다른 곳에서는 업데이트를 안 해주고
화면에 표시가 안 된다면 안되기 때문에
데이터를 사용하는 측에서도 변화를 알 수 있도록 해야 하는데...
자바스크립트는 애초에 반응형 프로그래밍 언어도 아닌지라 일일이 
개발자의 몫임
--> 이런 일들을 쉽게 해 주는 것이 바로 반응형 프로그래밍

즉, 데이터 변화하면 변화에 따라서 알아서 반응하는 프로그래밍

let price = 1000;
let quantity = 2;
let total = price * quantity;

price = 2000

console.log(`총 가격은 ${total} 원`);

------result--------
JS : 총 가격은 2000 원
reactive lang : 총 가격은 4000 원

반응형 언어 : 85년 논문에서 처음 등장했다고 보통 얘기됨.

위키피디아 
"반응형 프로그래밍은
데이터 스트림과
변화의 전파에 관련된
선언형 프로그래밍 패러다임이다."

스트림 : 시간 순으로 발생하는 이벤트의 나열
--> 반응형 프로그래밍에서는 모든 데이터를 스트림으로 본다.
--> 마우스 클릭, http 요청, 알림, 데이터 변화 등

선언형 프로그래밍 : 어떻게 할건지를 얘기하는 것이 아니라 무엇을
                할지를 말해주는 것
ex) 집에서 도서관까지 가는 법
명령형(어떻게 할지 다 알려줌) : 1 집에서 나와 
                        2. 500m 직진해 
                        3. 우회전 후에 200m 더 직진해
선언형(무엇을 해야하는지 알려줌) : 집에서 도서관까지 간다.

>종합 : 반응형 프로그래밍은?
    데이터 변경 
    --> 이벤트를 발생 
    --> 바뀐 데이터를 지속적으로 전달하는 역할

>핵심은 프로그램이 외부 환경과 어떻게 커뮤니케이션 하는가
제어권을 가진 자의 PULL & PUSH

데이터 생산자와 소비자 == 외부 환경과 프로그램

>PULL 방식
프로그램이 자체적으로 외부환경한테 명령
--> 원하는 데이터를 획득
: 프로그램이 제어(나)

>PUSH 방식
프로그램 입장에서는 PULL 방식이 귀찮
    - 계속 명령하고 응답을 기다리는 것을 반복해야 하니까
약속을 하게 됨
- 내가 물어볼때에 응답이 아니라 너가 바뀌었을 때에 알려줘
- 외부 환경이 제어
외부에서 응답이 오면 그때 그때 반응하는 형식
--> 비동기 처리에 유리

반응형 프로그래밍을 구현하려면...
누가 누구를 구독? 구독 시점은 언제? 
개념이 많아서 공부도 까다로워...
--> 리액트는 이런 반응에 관련한 내용들을 다 만들고 숨겨버림!!
--> 주어진 데이터를 가지고 어떻게 렌더링할지만 신경쓰면 됨

그럼 리액트는 반응형?
React is not Reactive!
: pull방식을 내부적으로 사용하면서 push인 것처럼 보이게 함
ex) setState를 연달아 두번 해도 두 번 렌더링이 안되지? 등

# 패턴
>observePattern
객체 상태의 변화를 관찰하는 옵저버 : 관찰자
관찰자를 객체의 구독을 해서 상태 변화 시마다 메소드를 통해서
객체가 목록에 등록된 관찰자들에게 통지를 하는 디자인 패턴
- 객체는 등록을 요청한 관찰자들을 배열로 가지고 있음

스테이트가 퍼블리시 : 객체 스테이트가 변화
--> 관찰자들에게 알려야함
--> 객체가 옵저버들한테 변환값인 스테이트를 포함해서 알려줌
- 이 전달방식이 fire 
--> 이에 따라서  알아서 옵저버들은 일을 하러 감

ex) 이벤트 핸들러
event : 구경당하는 객체 <-구독- 리스너 : 관찰자
                  -이벤트 발생 알림->

실시간으로 한 객체의 변화를 다른 객체에 전파를 해서 객체간의 의존성을
제거할 수 있는 장점!

>Pub/Sub Pattern
Publish/Subscribe Pattern
옵저버 패턴과 유사--> 변화된 형태

중간에 이벤트 관리자가 있음
중간에 이벤트 관리자를 구독, 이벤트 채널에 변화를 전달

구독자와 객체가 서로 직접적으로 서로 연락X
서로간의 결합도가 낮아짐
메시지 브로커로 제시징 큐를 많이 사용 --> 비동기 워크플로우 가능
: 서로 응답이 오면 알려줘 하면 이젠트 관리자가 알아서 그때마다 알림

--> 반응형 프로그래밍에 딱 알맞은 패턴

>Proxy Pattern
proxy : 대리
대신 해준다는 것
vpn과 더불어서 접근 불가능한 사이트로 접근할 수 있도록 하는 서비스도 있음

한국 --> 외국 불가능
요청 클라이언트인 나 대신 
나는 아니지만 나처럼 대신 데이터를 요청하고
받아주는 역할을 함

프록시 패턴이란?
하나의 객체가 프록시 역할을 수행
상황에 따라 다른 객체에 접근하게 해주거나
다른 함수를 수행할 수 있도록 함

프록시 객체 : 프록시 패턴을 사용할 때에 실제 객체를 대신하는 객체
ex)
function User() {
    this.users = ['A', 'B', 'C'];
}

Users.prototytpe.create = function(name, callback) {
}

Users.prototype.delete = function(name, callback) {
    this.users = this.users.filter(user => user !== name)
}

추가, 삭제 count를 알고 싶음
--> 만약 이를 위해서 객체를 뜯어 고친다면 이 객체를 사용하는 
    다른 측에서 문제 발생 가능
    (사이드 이펙트)
이를 위해서 프록시 객체를 만드는 것

function UserProxy() {
    let users = new Users();
    let count = 0;
    
    return {
        create: function (name, callback) {
            users.create(name);
            count += 1;
        },
        delete: function (name, callback) {
            user.delete(name);
            count += 1;
        }

        getUsers: function (name, callback) {
            return users;
        }
        getCount: function (name, callback) {
            return count;
        }
    }
}
진짜 유저를 감싼 객체를 만들어서 원본 객체를 수정하지는 않으면서
진짜 객체를 활용해서 새로운 일을 하는 객체를 하나 만들었음!

Proxy는 기존의 스테이트를 변경시키지 않으면서
그 스테이트 객체를 감싸서 사용할 수 있도록 해줌

리액트에서도 활용중 : event에서!
    이벤트를 프록시로 감싸서 사용하고 있기 때문에!
