파이썬/알고리즘

1bit = 0 or 1
크기 2

2bit = 0 1 / 0 0 / 1 0 / 1 1
크기 2 x 2 (경우의 수)

8bit 크기 2x2x2…. —> 2^8 = 256
—> 1byte


Ascii code —> ~1byte : 아쉽게도 한글은 없음
uni code —> 2byte~4byte : 한글 있음

1kb = 1024byte
1mb = 1024kbyte
1gb = 1024byte
1tb = 1024gb
—> 운영체제 bi를 붙여서 키비바이트, 메비바이트…. 테비바이트

10진수 단위로 표현
1kb = 1000byte
1mb = 1000kbyte
1gb = 1000byte
1tb = 1000gb
—> 외장 메모리

텍스트 인코딩
UTF-8(8bit) 1byte 기본 > UTF-16은 최소 2byte라서 낭비가 심함
Rob Pike(Go언어 창시자)
아스키, 유니코드 포함 인코딩

: 가변 길이 유니코드 인코딩
001110 : 1byte 필요할 때에 (2진수 값은 그냥 임의로 둔 값임)
10 + 001110 / 110 + 001110 : 2byte
10 + 001110 / 10 + 001110 / 1110 + 001110 : 3byte…….

// 빅오 vs 분할 상환 분석
빅오는 시간 복잡도에서 최악의 경우를 기준으로 나타낸다
그렇기에 동적 배열의 삽입시 시간 복잡도를 
새로운 값 삽입 = O(1) * n번 = O(n)
배열 더블링 후 기존 값 옮기기 = O(n)(값 옮기기) + O(1)(배열 늘리기는 1번)
즉, O(n) + O(n) + O(1) = O(n)(최고차항만, 상수는 무시)

반면 분할 상환 분석은 최악의 경우를 여러 번에 걸쳐서 골고루 나눠주는 형태로 시간 복잡도를 설명한다
새로운 값 저장하는 시간 = n
기존 값들을 더블링한 큰 배열에 복사해서 저장하는 시간
= 
x 번째 추가 	배열 크기		요소 저장에 걸린 시간
1			1			0
2			2			1
3			4			2
4			4			0
5			8			4
6			8			0
7			8			0
8			8			0
9			16			8
……즉, 9번(n) 추가 할 시에 기존 값 저장에 걸리는 총 시간은
8 + 4 + 2 + 1 = m + m/2 + (m/2)/2 + … + 1 이고 이 값은 절대로 2m을 넘을 수 없다
이 때에 m의 값은 새로 추가하는 값을 뺀 나머지 값들을 저장하는 시간이므로 n보다 클 수 없고,
이를 정리하면…

새로운 값을 저장하는 시간 n + 2n(보다는 작지만 최악의 경우 근사치) = 3n —> O(3n) = O(n)
그리고 이것은 n번 추가하는 경우이므로 1번 추가를 하는 데에는 n을 나누어
N(1)의 시간복잡도를 갖는다

// 파이썬의 숫자
int는 다른 c언어처엄 처음에는 고정 정밀도 정수형이었고, long이라는 임의 정밀도 숫자 타입이 존재
하다가 이후 2.4버전부터는 자동으로 int로 충분하지 않을 때에 long으로 바뀌다가 현재는 int 자체가
임의 정밀도를 지원하면서 파이썬에서는 더이상 고정 정밀도 정수형은 지원하지 않게 되었다

bool은 0과 1 즉, int의 하위 클래스
그런데 int는 object의 하위 클래스 이므로 
object > int > bool이 된다

// 파이썬의 매핑
키와 자료형으로 구성된 복합 자료형
딕셔너리

// 파이썬의 집합
set은 중복 허용하지 않는 자료형

a = set() 혹은 a = {‘a’, ‘b’, ‘c’}

딕셔너리와 마찬가지로 { }를 쓰기 때문에 주의가 필요하나 키와 value가 있는 딕셔너리와 보기에
차이가 크기 때문에 혼동하는 경우는 사실 많이 없다

// 시퀀스
수열
순서 있는 나열
str은 순서 있는 문자열의 자료형
list는 다양한 값의 순서 있는 나열
사실상 배열이 없는 파이썬에서는 list가 배열의 역할을 수행한다
시퀀스는 불변과 가변으로 구분하는데
불변에는 str, tuple, bytes가 있다
실제로 문자열은 바뀌지 않나? 하겠지만 사실 바꾸는 동시에 원래 문자열의 메모리 주소가 아닌
다른 주소를 할당하여 저장하기에 값이 바뀐다고 할 수 없다

// 원시타입 vs 객체
int long longlong 등 일정한 길이가 정해진 타입이 원시타입으로 물리메모리에 자료형의 크기만큼 
할당하여 연속된 순서로 배치된다 —> C / Java
반면, 객체는 숫자를 문자로 변환하거나, 16진수로 변환하거나 시프팅 같은 비트 조작을 할 수 있도록
하지만, 그만큼 메모리를 차지하는 정도가 상당히 커지게 된다
—> Java / Python

파이썬은 모든 것이 객체이고, 편리성을 우선시한다
반면, C는 편리성보다 성능에 대한 우선순위가 높다

파이썬의 객체 분변 가변 여부
불변 : bool, int, float, str, tuple
가변 : list, set, dict

참조 변수는 
10
a = 10
b = a 라고 했을 때에 b가 참조 변수이다
파이썬에서는 b = 7이라고 했을 경우 더이상 b는 a를 참고하지 않게 되어 
a = 10 / b = 7이 되지만, C++에서는 a = 7로 바뀌게 된다

// ==과 is
is는 id값을 비교
==은 값을 비교 

// 속도
파이썬은 모든 것이 객체이므로 값을 꺼내는데에 PyObject_HEAD에서 타입코드를 찾는 등 
부가 작업으로 속도가 느리지만 라이브러리인 numpy의 경우에는 C로 만든 모듈이며 내부적
으로 C의 원시 타입으로 처리를 하기 때문에 속도가 월등히 빠르다

// 자료구조
데이터에 효율적으로 접근, 조작하기 위한 데이터의 조직, 관리, 저장 구조 —> 학문으로서의 자료구조

// 자료형
데이터 속성 : 정수, 실수, 문자열 등 모든 자료의 유형

// 추상 자료형
ADT
자료형에 대한 수학적 모델을 지칭
해당 유형의 자료에 대한 연산들을 명기한 것
—> 객체 지향 프로그래밍(OOP)에서의 추상화(Abstraction)