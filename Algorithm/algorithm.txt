알고리즘?
- 수학자 이름에서 따옴
- 어떤 문제를 주로 컴퓨터로 풀기 위한 효율적인 절차!!

- 문제를 푸는 것뿐 아니라 단계별 절차를 명확하게 기술해내는 것!

알고리즘을 왜 공부?
- 어떤 문제를 컴퓨터로 해결하고 싶을 때 필요
- 특정 프로그래밍 언어나 문법과는 무관함
- 다양한 문제 해결 방법(알고리즘 설계 기법)을 공부함
    문제를 풀기 위한 공통적인 방법 --> 알고리즘 설계 기법!
- 알고리즘 문제를 이해 --> 효율적으로! 해결하는 방법을 공부함
    단계를 얼마나 단축할 수 있을까?
- 새로운 문제를 만났을 때에 효율적으로 해결할 수 있는 능력

문제와 해답?
- 문제란 해답을 찾으려고 물어보는 질문
- '파라미터'는 문제에서 특정한 값이 지어되어 있지 않은 변수
    입력되지 않은 변수 x
- '입력 샤례'는 문제의 파라미터에 지정된 특정한 값
    입력 사례 === 인스턴스
- 특정 입력사례에 해답은 해당 파라미터를 입력사례로 질문한 문제의 해답

알고리즘?
- 어떤 문제의 모든 입력 사례에 대해서 해답을 찾아주는 단계별 절차
    f(x) = x + 5에서 x에 어떤 값을 대입하든 이 값이 정답으로 나와야 함
    --> 그 답이 나오는 절차가 알고리즘

대표적인 알고리즘
# 순차 탑색 문제 (segunential search)
- 문제 : 어떤 수 x가 n개의 수로 구성된 리스트 S에 존재하는가?
    파이썬에는 배열이 없고 리스트를 쓰기에....
- 해답 : x가 존재하면 x의 인덱스가, 존재하지 않으면 0이 해답
- 절차는? 일단 대기
- 파라미터 : 정수 n(>0), 리스트 S(인덱스 범위는 1~n), 원소 x
    대부분의 인덱스는 1~n
- 입력 사례 :
    S = [0, 10, 7, 11, 5, 13, 8], n = 6, x = 5
        라고 주어졌다고 가정 
    - 참고로 알고리즘 기술 시에 0부터 시작하는 것보다 1부터 시작하는
      것이 훨씬 더 유리할 때가 많아서 인덱스 0의 값은 제외함.
    - 이를 pseudo-code(슈도코드, 의사코드)를 사용한다고 함.
- 입력 사례에 대한 해답 : location = 4
- 알고리즘 : 모든 S에 대해서 x의 인덱스를 찾아주는 단계별 절차
    1. S의 첫쩨 원소에서 시작해서 x를 찾을 때까지
        - x가 없는 경우는 끝까지
    2. 각 원소를 차례로 x와 비교한다.
    3-1. 만약 x를 찾으면 x의 인덱스를 리턴하고
    3-2. 만약 찾지 못하면 0을 리턴한다.

- 코딩
def seqsearch (n, S, x):
    location = 1
    while (location <= n and S[location] != x):
        location += 1
    if (location > n) :
        location = 0
    return location

S = [0, 10, 7, 11, 5, 13, 8]
x = 5
location = seqsearch(len(S) - 1, S, x)
// pseudo-code를 썼으므로 인덱스 0 값은 제외
print('location =', location)

#리스트(배열) 원소의 합 구하기
- 문제 : n개의 원소를 가진 리스트 S의 원소의 합을 구하시오
- 해답 : 리스트 S의 모든 원소들의 합
- 파라미터 : 리스트 S, 정수 n
- 입력 사례 : S = [-1, 10, 7, 11, 5, 13, 8], n = 6
- 출력 사례 : sum = 54
- 알고리즘 : 
    1. S의 모든 원소를 차례대로 sum에 더하는 절차
    2. 모든 S의 원소에 대해서 sum += S[i]를 실행
    3. sum의 값을 리턴

#리스트의 정렬 문제: sorting
- 다양한 해법이 존재
- 문제: n개의 수로 구성된 리스트 S를 비내림차순으로 정렬
- 해답: S를 비내림차순으로 정렬한 리스트
- 파라미터: S, n 
- 입력 사례: S = [-1. 10, 7, 11, 5, 13, 8]
- 입력 사례에 대한 해답: S' = [-1, 5, 7, 8, 10, 11, 13]
- 알고리즘:
    0. 모든 S에 대해서 S'를 찾아주는 단계별 절차
    --> 교환 정렬, 삽입 정렬, 선택 정렬, 합병 정렬, 퀵 정렬, 기타 등등
    (여러 가지의 알고리즘 중에서 교환 정렬 방법으로 구현해보자.)
    1. i번째 자리에 있는 수와 (i+1)번째부터 n번째 자리에 있는 수를 
       차례대로 비교
    2. 주어진 자리의 수가 i번째 자리에 있는 수보다 작은 경우, 두 수
       를 교환(swap)
    3. for-i 루프를 한 번 수행하면 그 중 가장 작은 수가 첫번째 자리
       에 들어감. 
    4. 두번째 루프를 수행하면 둘째 자리에 둘째로 작은 수가 들어감.
    5. 이런 과정을 통해서 오름차순으로 정렬이 된 S의 값을 구하고 리턴.

#행렬의 곱셈 문제
- 두 n * n행렬의 곱을 구하시오.
- 입력사례: n = 2,
          A = [a(11) a(12)]  B = [b(11) b(12)]
              [a(21) a(22)],     [b(21) b(22)]
- 입력사례에 대한 해답: C = A * B, (선행대수)
                   c(ij) = a(i1) * b(1j) + a(i2) * b(2j),
                   C = [28 38]
                       [26 36]
                    --> c(ij) = 시그마(k=1~n) a(ik)*b(kj)
