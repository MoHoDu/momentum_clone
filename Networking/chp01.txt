# 레이턴시와 대역폭 이해의 첫걸음 
"레이턴시가 무엇인가?"
레이턴시는 송신자측에서 수신자 측까지 패킷 데이터가 이동하는 데에
걸리는 시간을 의미한다.
다만... 여기에는 여러가지 지연 요소들이 존재한다. 
1. 전파 지연
이동거리에 대비한 신호가 이동하는 속도
2. 전송 지연 
패킷이 모든 비트를 내보내는 데에 필요한 시간
3. 프로세싱 지연
패킷 헤더를 처리하는데 걸리는 시간
4. 큐잉 지연
패킷이 처리될 때까지 버퍼 안에서 대기하는 시간 

게다가 라우터를 만나는 때마다 프로세싱 지연과 전송 지연을 겪게 된다. 
또한, 당연하게도 이동거리가 멀수록 레이턴시가 증가하고, 트래픽이 높
을수록 큐잉 지연의 확률도 늘어난다. 

"대역폭은 무엇인가?"
각 애플리케이션에서 물리적 혹은 논리적으로 처리 가능한 통신 경로의
최대 데이터 양을 뜻한다. 
메모리, CPU, usb까지도 대역폭을 지닌다.
보통 초당 비트 수인 bps를 사용해서 얘기한다.
장거리의 경우 광섬유 링크를 통해 전달되는데, 케이블마다 몇 가닥의 섬유
로 구성되어 있고 각각 수백 테라에 육박하는 대역폭을 가진다. 
하지만.. 전화선, 케이블, 가정용 라우터, 게이트웨이 등마다 다른 대역
폭을 가지고, 또, 많은 사용자가 접속된 상태에서는 대역폭이 상대적으로
줄어들게 된다. 

빛의 속도와 광섬유의 굴절률에 따르면 뉴욕에서 시드니까지 왕복 시간은
160밀리초이나, 집, 사무실에 도착하기 얼마 남지 않은 지점에서 개인의
네트워크 인프라, 각각 애플리케이션의 대역폭의 차이로 인해 대부분의 
레이턴시가 일어나게 된다. 

이 레이턴시로 인해 조금의 지연이 걸리게 되는데, 이 조금의 지연도 사
용자가 지루하다고 생각하는데 충분하다. 그렇기에 네트워크의 레이턴시를
주의 깊게 관리해야할 필요가 있다. 

# TCP의 구성요소 
신뢰 가능한 프로토콜인 TCP는 데이터 손실을 기정 사실화하고 이 손실을
막기 위해서 여러가지 기법을 사용한다. 
이 과정을 위해 먼저 송수신자는 3-way-Handshaking을 하는데, 이
과정에서 이미 왕복 레이턴시를 겪게 된다. 
어찌 되었든 이 과정이 필요한 이유는 혼잡 윈도우(cwnd)를 구하기 위함
인데, 3-way-Handshaking 중에서 보낸 SYN, ACK 패킷을 통해 그리
고, 송신에 대한 답이 이루어지는 시간에 따른 네트워크 상황을 고려해서
TCP는 이 혼잡 윈도우의 범위를 구한다. 
이는 수신측이 보낸 윈도우 크기인 RWND와 네트워크 상황을 고려해서 정한
CWND 중에서 더 작은 값을 최대 윈도우 크기로 사용한다. 그리고, 초기값
은 한번 통신 때에 보낼 수 있는 최대 단위인 MTU에서 IP와 TCP의 헤더
등의 데이터가 아닌 부분들을 전부 빼낸 MSS를 사용해 1MSS로 하여 값을
초기화한다. 

"혼잡 제어와 혼잡 회피"
그리고 나서 TCP는 전송 과정동안에 네트워크 혼잡에 대비해서 혼잡 제어
방법을 사용한다. 이 방법에는 두 가지가 대표적이다. 
1. AIMD 방식
우리 말로 직역하면 합 증가/곱 감소 방식이다.
네트워크에 별 문제가 없다면, 혼잡 윈도우의 크기를 1MSS씩 증가시키고
중간에 데이터가 유실되거나 응답이 오지 않는 등의 혼잡 상황이 발생하면
혼잡 윈도우의 크기를 반으로 줄인다. 
그래서 이 방식의 혼잡 윈도우를 시간에 따라 그래프로 그리면 톱니 모양
이 되는 것을 확인할 수 있다. 
단순하지만 이를 통하면 전체 호스트들의 윈도우 사이즈가 점점 평행을 맞
춰가는 등의 이점을 가질 수 있다. 
하지만, 이 방식은 윈도우 크기를 선형적으로 1MSS씩 증가시키기 때문에 
제대로 속도가 나오기 전까지 시간이 많이 걸릴 수 있다는 단점이 있다. 

2. 그래서 등장한 것이 Slow Start 방식이다. 
AIMD방식과 비슷하지만 이 방식에서는 윈도우 크기를 지수적으로 증가시키
고 혼잡 상황에서는 크기를 1로 줄여버린다. 
이 방식을 이요하면 초반에는 역시나 느리지만 금새 최대 속도에 도달할 수
있게 된다. 

어찌 되었든, 우리는 이를 이용해서 cwnd가 N이라는 크기에 다다르는 
시간을 구할 수 있는데, 공식은 다음과 같다. 
Time = RTT(서버와 클라이언트 왕복 시간) * [log2(N/초기 cwnd)]

다만, 결국 위 두 방식은 모두 TCP의 최대 윈도우 크기인 64KB에 도달
하기 위해서는 어느정도 시간이 걸리게 되고, 만약 송수신측의 거리가 길어
지면 더욱 더 많은 시간이 소요되게 된다. 이는 네트워크 성능과 대역폭을
늘리는 것과는 상관없이 걸리는 시간이다. 

이 시간을 줄이기 위해서는 클라이언트와 서버의 왕복 거리를 줄이는 방법을
사용할 수 있다. 

물론 이 느린 시작은 그래도 큰 데이터를 스트리밍하는 데에는 처음에는 느
리더라도 금새 최대의 속도로 증가하기 때문에 크게 속도의 차이가 안 날 수 
있다.
하지만, 대부분의 HTTP 커넥션에서는 연결이 짧고 일시적인 경우가 많기에
대역폭의 제한을 걸어버리는 느린 시작은 부작용으로 다가올 수 있다. 

그리고, 혼잡 상황에서 윈도우 크기를 줄이는 일명 혼잡 회피의 경우도 이
부작용을 크게 적용시키는데에 한 몫한다. 

"대역폭 지연 곱"
앞전에 수신자의 윈도우 크기(rwnd)와 혼잡 윈도우(cwnd) 크기 중 최소
값을 최대 데이터 전송 크기라고 정의했다는 것을 기억할 것이다. 
(ACK를 응답 받지 않은 상태에서의)

만약 ACK를 둘 중 하나라도 받지 않은 상태에서 이 데이터 최대 전송량을
초과하게 된다면 ACK가 올 때까지 전송을 중단하고 대기해야 한다. 
이 시간은 송수신자 사이의 데이터 왕복 시간에 의해서 결정된다. 
여기서 대역폭 지연 곱은 데이터 링크의 허용량과 종단 간 지역을 곱한 값
으로 결과 값은 ACK를 받지 않고 이동할 수 있는 데이터의 최대 양이 된다.

결국 지정한 윈도 사이즈가 작다면 커넥션 처리량은 아무리 좋은 대역폭을
지녔다고 할지라도 제한될 수 밖에 없다. 
이룰 해소하기 위해서는 최소 윈도우의 크기를 늘리거나 왕복 시간을 줄여야
만 한다. 
TCP의 최대 윈도우 크기의 경우에는 64KB인데 윈도 스케일링 옵션으로 이 
값을 증가 시킬 수도 있고, 불행 중 다행히 윈도 크기의 상호 조정은 네트워
크 스택에서 자동으로 이루어지고 있다.
다만, 최소 윈도우 크기나 네트워크 문제, 포화 상태에 이른 지점(peer) 등
의 이유로 윈도우 사이즈가 작거나 리셋되면서 여전히 높은 전송률을 가질 수 
있는 클라이언트와 서버 사이에서도 제한된 속도로 데이터가 전송되는 이유이다.

"TCP head-of-line(HOL)"
TCP는 신뢰할 수 있는 프로토콜인 만큼 데이터 손실과 순서 뒤바뀜에 대비해
각 패킷마다 고유의 시퀀스 번호를 지니게 하고 이 순서대로 전달시킨다. 
이런 순서로 전달하다가 혹여나 중간에 한 패킷이 소실되거나 하면 소실된 패킷
이 다시 제대로 전달될 때까지 이후의 패킷들은 모두 대기 상태에 들어간다. 그
리고, 이 모든 과정이 끝난 뒤에서야 애플리케이션은 데이터에 접근할 수 있다.
이러한 현상을 HOL 블로킹이라고 한다. 

이의 장점은 애플리케이션이 이후 패킷의 재배치나 재조합에 관여할 필요 없이
순서를 맞춰서 전달한다는 것으로 이후 애플리케이션의 코드가 훨씬 간단해질 수 
있다는 점일 것이다. 
단점은 패킷이 도착하는 시간이 들쭉날쭉해지면서 정확한 레이턴시를 예측하기 어
려워진다는 것으로 이러한 현상을 지터 라고 부르며, 이는 애플리케이션의 성능에
좋지 않은 영향을 끼칠 수 있다. 

그러므로 데이터 전송의 순서나 신뢰성이 중요하지 않은 애플리케이션의 경우에는 
이런 TCP는 단점만 남을 수 있다. 곧 이런 애플리케이션 예를 들면 오디오 스트
리밍 등의 경우에는 다른 프로토콜이 더 유용할 가능성이 높다.

"더 빠른 데이터 전송을 위한 방법들"
1. TCP의 최적화
현재 네트워크의 상황에 따라서, 상위, 하위 계틍의 종류와 각종 요구사항에 따라
서 다른 혼잡 제어 알고리즘을 찾는 등의 TCP 튜닝과 최적화가 이루어질 수 있다. 
다만, 각각의 애플리케이션의 요구사항이 다르고, 알고리즘도 각각 설정해야 하는 
사항들이 많고 다르기 때문에 철저한 연구가 필요하다.

일단, 가장 중요한 것은 대부분의 경우의 TCP 커넥션의 병목지점이 대역폭이 아닌 
레이턴시에서 이루어진다는 것이다. 

2. 서버 설정 조정
TCP의 특정 버퍼나 타임아웃 변수를 조정하기 전에 일단 사용하는 호스트를 최신 
시스템 버전으로 업그레이드하는 것이 좋다. 
왜냐하면 TCP의 성능을 좌우하는 최신 알고리즘들이 점점 최신 커널을 요구하기 
때문이다. 
최신 커널로 업그레이드한 이후에는 서버가 다음 기분에 맞춰서 올바르게 설정이 되었
는지 확인해야 한다. 
2-1. TCP의 초기 혼잡 윈도 크기 증가 
 - 혼잡 윈도의 크기가 크면 첫 왕복에 더 많은 데이터를 전송할 수 있고, 더 신
 속하게 윈도 크기를 키울 수 있다. 
2-2. 느린 시작 다시 시작하기
 - 유휴 상태(idle)가 끝난 후에 느린 시작을 비활성화 시키면 수명이 길고 한 번
 에 데이터 전송이 많은 TCP 커넥션의 성능을 높일 수 있다. 
2-3. 윈도 스케일링 
 - 이를 활성화 시키면 최대 윈도 크기를 64KB 이상으로 늘릴 수 있고, 레이턴시가
 높은 커넥션에서 처리량을 개선할 수 있다. 
2-4. TCP Fast Open 
 - 특정 상황에서 첫 SYN 패킷 내에 애플리케이션 데이터를 전송할 수 있게 해준다. 

3. 애플리케이션 동작 튜닝 
3-1. 데이터 비트를 보내지 않는 것보다 빠른 방법은 없다는 것은 당연하다. 즉, 더 적은
     수의 비트를 전송하게 해야 한다. 
3-2. 데이터를 빠르게 이동시키는 것은 불가능해도 서버의 위치 등을 조정해 이동 거리
     를 줄일 수 있다. 
3-3. TCP 커넥션을 재사용하는 것은 성능 향상에 매우 중요하다.
      - 느린 시작이나 다른 혼잡 처리 메커니즘을 줄일 수 있다. 

3. 성능 체크리스트
 - 서버 커널 최신버전으로 업그레이드
 - 혼잡 윈도 크기는 10으로 설정
 - 유휴 상태 후 느린 시작을 비활성화 
 - 윈도 스케일링을 활성화 
 - 불필요한 데이터 전송을 피하기 
 - 전송 데이터를 압축하기 
 - 서버를 사용자와 가까운 곳에 배치하여 왕복 시간 줄이기 
 - 기존 TCP 커넥션을 가능한 재사용

# UDP의 구성요소 
UDP는 TCP/IP 프로토콜이 소개된지 한참 지난 뒤에야 등장 
흔히 NULL Protocol이라고 불리는데, 이는 UDP가 다채로운 기능이 아니라
많은 기능의 과감한 생략이라는 단순함에 그 강점이 있기 때문이다. 

"데이터그램과 패킷의 차이"
데이터그램은 전송 네트워크 계층에서 보장하는 신뢰 기반의 데이터 교환에
의존하지 않고 충분한 양의 정보를 발신자에서 목적지까지 스스로 운반할 수
있는 독립적인 데이터 객체를 말한다. 
즉, 패킷이 일반적인 데이터 덩어리라면 데이터그램은 불안전하고 전송 실패에 
대한 노티피케이션도 없는 신뢰할 수 없는 서비스를 통해 전달되는 패킷이다. 

UDP에서의 패킷은 패킷보다 데이터그램이라 칭하는 것이 옳다. 

UDP의 가장 대중적인 예는 브라우저와 인터넷 애플리케이션이 의존하고 있는 
도메인 네임 시스템인 DNS이다. 
브라우저가 데이터 교환 전에 DNS를 통해 컴퓨터의 IP를 알아내야 한다. 
이렇게 기존에 브라우저가 UDP에 어느정도 의존하고 있음에도 데이터 전송 수단
으로 이 UDP를 사용하지는 않았다. 
하지만, WebRTC가 등장하고부터 상황이 달라졌다. 

WebRTC은 IETF와 W3C 워킹그룹이 함께 개발한 표준 기술로, 
UDP를 이용해 브라우저 내에서도 음성 통화, 화상 통화 또는, P2P 통신 같은
실시간 커뮤니케이션을 가능하게 하였다. 

"왜 null protocol인가? with. IP"
이 이유는 한 계층 아래에 존재하는 IP에 대해 먼저 살펴보아야 한다. 
IP의 주된 임무는 발신자와 수신자의 주소를 기반으로 데이터그램을 운반하는 것
이다. 
다시말해서 IP가 메시지를 안전하게 전달하지도 않고, 메시지가 전송에 실패해도 
실패 통지를 하지 않는다는 것이다.
그리고 이런 손실이 발생하면 IP보다 위 계층에 있는 프로토콜이 이를 탐지해서 
누락된 패킷을 복구하는 일을 대신하게 된다. 

수신지 호스트에서 IP 패킷을 받았을 때에 호스트가 UDP 패킷을 열고 수신지 
포트에서 타깃 애플리케이션을 찾아내 메시지를 전달하는 것은 TCP를 사용하는
것과 맥락은 똑같지만, UDP는 섬세하지 않다. 

먼저 헤더를 보면, TCP와 다르게 UDP의 경우는 SP/DP의 포트번호와 16비트의 
체크섬이라는 필드만 존재한다. 이로인해 UDP는 TCP처럼 흐름 제어, 혼잡 제어,
커넥션이 없으며, 메시지가 무사히 도착할 것이라는 보장을 할 수 없고, 순서대로
패킷이 전달되지 않는다. 단지 체크섬을 통해 에러만 확인할 수 있다. 
--> 그로 인해서 UDP를 null protocol이라고 일컫는 것이다. 

또한, UDP는 상위에서 전달된 데이터를 쪼개지 않는다. 
그렇기 때문에 하나의 UDP 데이터그램 메시지는 완전한 메시지이다. 

"UDP와 네트워크 주소 변환기"
IPv4 주소 길이는 단 32비트로 제공할 수 있는 최대 고유 IP 수는 총 42억 
4천만 개에 불과하다. 많은 것 같지만 인터넷 호스트 수가 90년대 초부터 기하급
수적으로 증가하고 나서는 모든 호스트에게 고유 IP를 붙일 수 없음이 명백해졌다.

그래서 94년 중반에 NAT(IP Network Address Translator) 스펙이 처음 
소개되었다. 이는 네트워크 끝에 NAT 기기를 설치해서 로컬 IP와 포트 번호를 한
개 이상의 고유 공용 IP와 포트 번호에 짝지어서 관리하는 방식이다. 
예를 들면 공유기 뒷편의 로컬 IP 주소 공간을 다른 네트워크가 재사용하면서 여러
컴퓨터, 스마트폰 등의 기기가 네트워크에서 해당 IP를 사용한다. 
이는 또한, 개인의 IP를 공인 IP로 숨길 수 있기 때문에 외부로 트래픽이 나갈 때
해커 등의 공격자가 개인의 IP를 알기 어렵다는 보안 상의 장점도 있기에 중요한 
기술이라고 할 수 있습니다. 
(~44p)

# 전송 계층 보안 